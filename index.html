<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Revolve: An Evolutionary Robotics Toolkit</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">
		<link rel="stylesheet" href="css/revolve.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>
	<body>
		<div id="video-background">
			<iframe style="width:100%; height:100%;"
					src="https://youtube.com/embed/4ADNOUnD6Gc?autoplay=1&controls=0&showinfo=0&autohide=1&loop=1&playlist=4ADNOUnD6Gc&modestbranding=1">
			</iframe>
		</div>
		<div class="reveal">
			<div class="slides">
				<section data-state="with-video">

					<div class="overlay-block">
						<h1>Revolve</h1>
						<h2>An Evolutionary Robotics Toolkit</h2>
					</div>

				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Outline</h3>
					<ol>
						<li>Background</li>
						<li>What & Why</li>
						<li>How: Introducing Revolve</li>
						<li>Experimental Setup</li>
						<li>Results</li>
						<li>Conclusions & Recommendations</li>
					</ol>
					<!-- Writing the asides as a story because I find it easier to determine the
					     flow of the presentation that way. Maybe remove the notes later to prevent
					     it from actually becoming a read story. -->
					<aside class="notes">
						Today, I'll be presenting the work of my Master's thesis, which is about evolving robots.
						This may sound a little bit "out there" for most of the audience, so I am going to start
						with a quick primer on what that actually means. I will then tell you what it is that
						I've been aiming to achieve, and why. I'll introduce the Revolve toolkit and tell you
						what it's designed to do. I will then walk you through the setup of the experiments that
						I performed with this toolkit, followed by their results, and conclusions.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Solving problems using evolution</h3>
					<ol>
						<li class="fragment">Genotype, "DNA"</li>
						<li class="fragment">Phenotype</li>
						<li class="fragment">Fitness</li>
						<li class="fragment">Reproduction (combination & mutation)</li>
						<li class="fragment">Candidate solutions</li>
					</ol>

					<aside class="notes">
						When faced with a problem that is difficult to optimize, we can resort to evolution as
						a heuristic. Provided we agree that evolution is what shaped a lot of living
						and non-living entities around us, I think it's fair to say that the process is a good
						problem solver. To solve a problem with evolution, we need just a few things:
						<ol>
							<li>A genotype, the "DNA" of a solution</li>
							<li>A phenotype, the actual solution itself</li>
							<li>A way to measure the quality of a solution, "fitness"</li>
							<li>A way to combine and mutate genotypes</li>
							<li>A starting set of candidate solutions</li>
						</ol>

						It's important to note that we're not talking about <emph>actual</emph> DNA here: a
						genotype can be anything, as long as it expresses a solution somehow and we can
						apply evolutionary operators on it.

						Given a set of candidate solutions, we can evaluate them for their fitness, choose individuals
						to reproduce and thereby produce a new set of candidate solutions. When done right and repeated
						sufficiently often, this results in better and better candidate solutions. This process is
						likely familiar to many from real life, where it is known as "breeding". This is the same thing,
						except rather than natural organisms, we're using artificial problems.


					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Evolutionary Robotics (ER)</h3>
					<ul>
						<li>In simulation</li>
						<li>In real time, <emph><i>real space</i></emph></li>
						<li>Evolution of Things</li>
					</ul>
					<aside class="notes">
						In principle evolution can be applied to anything, and Alan Turing already had the idea to apply
						it in computation; it's at least as old as the computer itself. Applying it to robotics
						is arguably even more akin to biological evolution than in general computation, and has
						by now been done

						Taking a big leap forward, recent technology has provided us with the means to rapidly
						manufacture physical structures using 3D-printing, which sparks the desire to take evolution
						back to the real world, by evolving robots in real time and in real space, otherwise
						known as the Evolution of Things.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Simulation</h3>
					<ul>
						<li>Hardware: (still) slow & expensive</li>
						<li>Many iterations required</li>
						<li>Simulation can help</li>
					</ul>
					<aside class="notes">
						I hear you thinking, "what's this guy on about physical robots, I thought this defense
						was for Computational Science", and you're right. Even though we can by now produce robots
						mechanically, hardware is still slow and expensive to work with. To validate whether a
						certain hypothesis might be worth exploring, we can simulate entire environments. Which
						brings me to the subject of my thesis.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>ER Simulation: Requirements</h3>
					<ul>
						<li>Flexible</li>
						<li>Fast to set up</li>
						<li>Fast to execute</li>
					</ul>
					<aside class="notes">
						If our goal is to essentially scout the experiment space for worthwhile ideas, we should
						be able to do so rather easily. Therefore simulation tools need to comply to a few requirements.
						They need to be flexible, so we can set up our experiments in the way that we want, and we
						don't want to waste too much time setting them up and executing them.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>The <i>R</i>obot <i>Evolve</i> Toolkit</h3>
					<ul>
						<li>Builds on top of
								<img src="./img/gazebo.png" height="25px" alt="Gazebo"
									 style="vertical-align:middle; border-color:#ffffff;" /></li>
						<li>Multi-layered:
							<ul>
								<li>High performance: C++</li>
								<li>Setup and bootstrap: Python</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						The lack of a current software package meeting this requirement has led me to develop
						Revolve. It builds on top of the free, open source Gazebo simulator. Gazebo is a very
						flexible robotics simulator, with support for a variety of physics engines and several
						interfaces to its simulation environment. Revolve uses these interfaces to add a set
						of utilities that simplify the creation of robot structures and environments.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Revolve basics: the specification</h3>
					<p class="left">Given:</p>
					<ol>
						<li>A predefined set of (arbitrary) <i>body parts</i>, with predefined
							<i>attachment slots</i></li>
						<li>A labeled tree graph <i>blueprint</i></li>
					</ol>
					<p class="left">Revolve can construct a robot to simulate with Gazebo.</p>

					<aside class="notes">
						At the heart of Revolve lies the Revolve Specification, which allows for the construction
						of arbitrary robots from a predefined set of body parts. Each of these body parts has
						a number of attachment slots, i.e. locations at which parts attach to each other. A
						specific robot body is then specified using a labeled tree graph, where the nodes
						are the body parts and the labeled edges the attachments between these body parts.

						Given such a blueprint, Revolve can construct a robot in the SDF format that can be
						simulated by Gazebo, taking into account all the physical properties of the combination.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Example (2D)</h3>
					<p>
						<img src="./img/sample_parts.png" height="250px" alt="Parts" class="fragment valign">
						<span class="fragment">+</span>
						<img src="./img/blueprint_1.png" height="250px" alt="Blueprint" class="fragment valign">
						<span class="fragment">=</span>
						<img src="./img/result_1.png" height="250px" alt="Result" class="fragment valign">
					</p>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Research</h3>
					<p>Off-line versus on-line evolution</p>
					<p class="fragment"><i>What happens between off-line and on-line?</i></p>

					<aside class="notes">
						Given this software toolkit, we would like to prove its worth by performing some simulations.
						Most evolutionary robotics research so far considered specific optimization problems in
						what we could call off-line evolution, which is characterized by a separation in the
						simulation process: a robot is constructed, evaluated for fitness, conditionally reproduced -
						repeat until the desired result is achieved. Revolve on the other hand is designed for
						simulation of real-life scenarios which are continuous and integrated, with evaluation
						and reproduction happening in active populations inside some environment.

						An interesting question to answer is therefore how this transition from off-line to
						on-line evolution affects the performance of individuals, and in my thesis I've setup
						an experiment to investigate this question.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Experimental setup</h3>
					<ul>
						<li>Three scenarios, off-line to on-line</li>
						<li>Genome: Revolve spec + neural network</li>
						<li>RoboGen [1] body parts</li>
					</ul>
					<p><a href="http://www.robogen.org">[1] http://www.robogen.org</a></p>

					<aside class="notes">
						The setup of this experiment aims to provide three similar simulation scenarios, which
						vary in the degree one would consider them on-line. We use the body space from RoboGen,
						a major precursor to this work, adapted to the Revolve specification. We extend the
						Revolve blueprint with neural network properties such that the robot has an evolvable
						brain that controls the motors. The body parts are taken from RoboGen.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Body parts</h3>
					<div class="body-part-row">
						<span class="body-part">
							<img src="./img/body_parts/CoreComponent.png" alt="">
						</span>
						<span class="body-part">
							<img src="./img/body_parts/FixedBrick.png" alt="">
						</span>
						<span class="body-part">
							<img src="./img/body_parts/ParametricBarJoint.png" alt="">
						</span>
					</div>
					<div class="body-part-row">
						<span class="body-part">
							<img src="./img/body_parts/PassiveHinge.png" alt="">
						</span>
						<span class="body-part">
							<img src="./img/body_parts/ActiveHinge.png" alt="">
						</span>
						<span class="body-part">
							<img src="./img/body_parts/TouchSensor.png" alt="">
						</span>
					</div>

					<blockquote class="fragment">"Wheels are boring"</blockquote>

					<aside class="notes">
						Here we see the body parts that were used for the robots in the experiments. These body parts
						were taken from RoboGen. Most of the parts are static, but we have one part that can produce
						locomotion (the active hinge), and two parts with sensors: the core component and
						the touch sensor.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Scenarios: similarities</h3>
					<ul>
						<li>Random starting population</li>
						<li>Fitness: <i>f(p) = v + 5s</i></li>
						<li>Evaluation time: 12s</li>
						<li>Parent selection: 4-tournament</li>
						<li>3000 total individuals</li>
					</ul>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Scenarios: differences</h3>
					<table>
						<tr><th></th><th>Sc. 1</th><th>Sc. 2</th><th>Sc. 3</th></tr>
						<tr><th>Scheme</th><td>15 + 15</td><td>15 + 1</td><td>Dynamic</td></tr>
						<tr><th>Survivor</th><td>Best 15/30</td><td>Best 15/16</td><td>Best 30% or in best 8</td></tr>
					</table>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Scenarios: baseline & performance</h3>
					<ul>
						<li>No reproduction</li>
						<li>No selection</li>
						<li>Execution speed</li>
					</ul>
				</section>

				<!------------------- SLIDE -------------------------------->
				<section>
					<h3>Results</h3>

					<aside class="notes">
						Each of the aforementioned experiments was repeated 30 times to obtain
						adequate averages. The runs produced a lot of data, from which I extracted various
						statistics. The data I'll present here is a selection from the most relevant
						processed data.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Fitness - final populations</h3>
					<img src="./img/plots/fitness.png" alt="Fitness" class="plot">

					<aside class="notes">
						This plot shows the average fitness of the final populations, which is clearly
						higher in scenario's 1 and 2. Let's find out what causes this.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Fitness - progression</h3>
					<img src="./img/plots/fitness_births.png" alt="Fitness over time" class="plot">
					<aside class="notes">
						Here we have the fitness progression over time. To obtain a unified scale across the
						experiments, we use the total number of births in the system as a time scale.

						We see all scenario's initially taking off, after which scenario 3 continues at a much
						slower increase than the other two. None of the bars have flattened out yet, so it might
						have been interesting to run these experiments even longer.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Gene Diversity</h3>
					<div style="overflow: auto;">
						<img src="./img/plots/diversity.png" alt="Diversity" class="plot" style="width:45%; float:left;">
						<img src="./img/plots/diversity_time.png" alt="Diversity over time" class="plot" style="width:45%; float:right;">
					</div>

					<aside class="notes">
						One of the things we can use to find out what causes the differences in fitness is
						the genetic diversity in final populations. Here we use a simplified metric based on
						Tree Edit Distance to determine how different robots in the final populations are.
						We observe a higher gene diversity in robots in the on-line experiment.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Retention rate</h3>
					<img src="./img/plots/refresh_120.png" alt="Retention rate" class="plot">

					<aside class="notes">
						Another metric we can observe is the retention rate - the fraction of robots from
						a certain population that is still alive after a fixed time interval. Here we show
						that retention rate for a time interval of n = 120 births. Observe how scenario 1 and 2
						are very similar, whereas robots in scenario 3 have a much lower likelihood of still
						being alive 120 births later.

						A low retention can happen if new robots are often fitter than older robots, which accounts
						for most of the slopes' angles. The difference between the experiments can only have one other
						explanation, which we observe in the following slide...
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Fitness diversity</h3>
					<img src="./img/plots/fit_diff.png" alt="Fitness" class="plot">
					<aside class="notes">
						Robots in an on-line scenario have fluctuating fitness values.
						This slide shows probability density of the relative difference in fitness for any robot
						within a single active population. We see that large fluctuations are rather common,
						meaning that a robot that is very fit at one point can be remarkably unfit at another.
						This uncertainty lowers the retention rate.
					</aside>
				</section>

				<section>
					<h3>Experiment conclusions</h3>
					<ul>
						<li class="fragment">Differences in fitness (progression)</li>
						<li class="fragment">Continuous evaluation - larger diversity</li>
					</ul>
				</section>

				<!------------------- SLIDE -------------------------------->

				<!--<section>-->
					<!-- REMOVED, getting too long -->
					<!--<h3>Robot size</h3>-->
					<!--<img src="./img/plots/num_parts.png" alt="Robot size" class="plot">-->
				<!--</section>-->

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Performance</h3>
					<img src="./img/plots/benchmark.png" alt="Benchmark" style="width:65%;">

					<aside class="notes">
						This slide shows the execution performance of simulating a population of average robots.
						The Real Time Factor is the amount of seconds of simulation time per second of normal time
						that can be achieved on regular hardware. These results come with a number
						of caveats, because performance depends largely on the required accuracy, simulated parameters
						and properties of the robots involved. That being said, a real time factor of 1.0 is reached at
						around 28 individuals for these specific experiments.
					</aside>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Conclusions</h3>
					<ul>
						<li>Utility</li>
						<li>Performance</li>
						<li>Experiments</li>
					</ul>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section>
					<h3>Recommendations & Future Work</h3>
					<ul>
						<li>Reality gap</li>
						<li>Sensors & brains</li>
						<li>Parameter tuning</li>
						<li>Artificial Ecosystems (Triangle of Life)</li>
					</ul>
				</section>

				<!------------------- SLIDE -------------------------------->

				<section data-background-image="./img/robot.png">
					<h3 class="overlay-block">Questions</h3>
				</section>

			</div>
			<div id="footer">Elte Hupkes</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				slideNumber: "c/t",

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
		</script>
	</body>
</html>
